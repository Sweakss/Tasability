; NohBridge.ahk

#NoEnv
#SingleInstance Force
SendMode Input
SetWorkingDir %A_ScriptDir%
CoordMode, Mouse, Screen

; -------------------- user-provided workspace checks --------------------
if !FileExist("workspace")
{
    MsgBox, Put this file one folder above your exploit's workspace folder then run it again (your exploit folder)
    ExitApp
}

if !FileExist("workspace/NohBridge+_AHK") 
{
    FileCreateDir, workspace/NohBridge+_AHK
    MsgBox, Bridge AHK folder has been added to workspace
}

if !FileExist("workspace/NohBridge+_AHK/Request")
{
    writefile := FileOpen("workspace/NohBridge+_AHK/Request", "w")
    writefile.Write()
    writefile.Close()
    MsgBox, Request file has been added to Bridge AHK folder
}
; ------------------------------------------------------------------------

; -------------------- configuration --------------------
frameDelay := 1/60       ; ms per frame. Adjust to match TAS playback FPS (16 ~ 60fps)
jsonFile := "workspace/NohBridge+_AHK/frameKeys.json"  ; file produced by TAS (Lua)
trackedKeys := ["W","A","S","D","Space","LeftShift"]
; -------------------------------------------------------

; include JSON library - put JSON.ahk in the same folder
; Download suggestion: https://github.com/cocobelgica/AutoHotkey-JSON
#Include JSON.ahk

; helper maps: AHK key tokens for keys (normalize names if needed)
KeyToken := {}
KeyToken["W"] := "w"
KeyToken["A"] := "a"
KeyToken["S"] := "s"
KeyToken["D"] := "d"
KeyToken["Space"] := "Space"
KeyToken["LeftShift"] := "LShift"

; ensure file exists
if !FileExist(jsonFile)
{
    MsgBox, 48, NohBridge, JSON file not found:`n%jsonFile%`nExport frameKeys.json from TAS first.
    ExitApp
}

; read and parse JSON
FileRead, jsonData, %jsonFile%
if (ErrorLevel)
{
    MsgBox, 16, NohBridge, Failed to read JSON file.
    ExitApp
}

; parse json using JSON.ahk
frameKeys := JSON.Load(jsonData)
if (!frameKeys)
{
    MsgBox, 16, NohBridge, Failed to parse JSON. Check JSON.ahk and the JSON structure.
    ExitApp
}

; Determine frame count (assumes frameKeys is an array-like object)
; Attempt to get length in a few ways (compatibility with different JSON libs)
frameCount := 0
if IsObject(frameKeys) {
    ; try common properties
    if frameKeys.HasKey("length")
        frameCount := frameKeys.length
    else if frameKeys.HasKey("Length")
        frameCount := frameKeys.Length
    else {
        ; fallback: check numeric indices
        i := 1
        while true {
            if frameKeys.HasKey(i)
                frameCount := i
            else
                break
            i += 1
        }
    }
}
if (frameCount = 0) {
    ; try using a generic loop until missing index (last resort)
    i := 1
    loop {
        try {
            val := frameKeys[i]
        } catch e {
            break
        }
        if !IsObject(val) && val = ""
            break
        frameCount := i
        i += 1
        if (i > 1000000) ; safety break
            break
    }
}

if (frameCount = 0)
{
    MsgBox, 16, NohBridge, Could not determine frame count from JSON. Verify format (array of frames).
    ExitApp
}

; Playback variables
prevState := {}  ; prevState[key] = true/false (pressed)
Loop, % trackedKeys.Length()
    prevState[ trackedKeys[A_Index] ] := false

; playback loop
MsgBox, 64, NohBridge, Starting playback of %frameCount% frames. Click OK to begin.
Loop, % frameCount
{
    idx := A_Index
    ; get frame object
    frame := frameKeys[idx]
    ; if frame is empty, skip
    if !IsObject(frame) && frame = ""
    {
        Sleep, frameDelay
        continue
    }

    ; Determine which of the tracked keys are present this frame
    currentState := {}
    for keyIndex, keyName in trackedKeys
    {
        currentState[keyName] := false
    }

    ; Some JSON libs represent arrays/objects differently.
    ; We accept that frame may be an object where keys are present as boolean true or list.
    ; Try these common shapes:
    ; 1) frame = { "W": true, "mouseX": 100, ... }
    ; 2) frame = ["W","Space", "mouseX":100, ...]  (less typical)
    ; 3) frame has numeric array part listing keys (less typical)
    try {
        ; If frame.HasKey works, check presence
        if (frame.HasKey) {
            ; check tracked keys
            for keyIndex, keyName in trackedKeys {
                if frame.HasKey(keyName) {
                    ; ensure truthy
                    val := frame[keyName]
                    if (val)
                        currentState[keyName] := true
                } else {
                    ; check if numeric list contains key
                    ; attempt to iterate numeric indices if present
                    i := 1
                    while frame.HasKey(i) {
                        if (frame[i] = keyName) {
                            currentState[keyName] := true
                            break
                        }
                        i += 1
                    }
                }
            }
            ; mouse coords
            mouseX := frame.HasKey("mouseX") ? frame["mouseX"] : (frame.HasKey("mouse_x") ? frame["mouse_x"] : "")
            mouseY := frame.HasKey("mouseY") ? frame["mouseY"] : (frame.HasKey("mouse_y") ? frame["mouse_y"] : "")
        } else {
            ; fallback: try numeric indices
            ; scan array part for keys (if frame acts like an array)
            i := 1
            mouseX := ""
            mouseY := ""
            loop {
                try {
                    v := frame[i]
                } catch e {
                    break
                }
                if (v = "")
                    break
                if (v = "mouseX") {
                    mouseX := frame[i+1]
                } else if (v = "mouseY") {
                    mouseY := frame[i+1]
                } else {
                    for keyIndex,keyName in trackedKeys {
                        if (v = keyName) {
                            currentState[keyName] := true
                        }
                    }
                }
                i += 1
                if (i > 10000)
                    break
            }
        }
    } catch e {
        ; parsing error - treat as no keys this frame
        mouseX := ""
        mouseY := ""
    }

    ; Press/release keys comparing with prevState
    for keyIndex, keyName in trackedKeys
    {
        if currentState[keyName] and !prevState[keyName]
        {
            ; press down
            SendInput, {% KeyToken[keyName] % down}
            prevState[keyName] := true
        }
        if !currentState[keyName] and prevState[keyName]
        {
            ; release
            SendInput, {% KeyToken[keyName] % up}
            prevState[keyName] := false
        }
    }

    ; Move mouse if coords are present (absolute screen coords expected)
    if (mouseX != "" && mouseY != "") {
        ; Ensure numerical values
        ; MouseMove expects integers
        mx := mouseX
        my := mouseY
        ; In case JSON numbers are strings, convert:
        mx := mx + 0
        my := my + 0
        MouseMove, % mx, % my, 0
    }

    Sleep, frameDelay
}

; release any remaining pressed keys
for keyIndex, keyName in trackedKeys
{
    if prevState[keyName]
        SendInput, {% KeyToken[keyName] % up}
}

MsgBox, Playback finished.
ExitApp